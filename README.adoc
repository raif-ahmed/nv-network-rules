= Define Multitenant isolation for namespace

In this post we will examine using NeuVector Network rules to enable multi-tenancy isolation in openshift. Also how we can isolate external ingress & egress traffic from specific workload.


.References :
** https://docs.openshift.com/container-platform/4.12/networking/network_policy/multitenant-network-policy.html[Configuring multitenant isolation with network policy]
** https://open-docs.neuvector.com/[NeuVector Docs]
https://docs.openshift.com/container-platform/4.13/networking/openshift_sdn/configuring-egress-firewall.html[Configuring an egress firewall for a project]


:sectnums:

== Multitenant isolation
In OCP 4 By default, all Pods and services in a project are accessible from other Pods in different namespaces. You can restrict this behavior either by using Networkploicies or use the multitenant isolation mode for the OpenShift SDN network.


Blocking connections from a namespace to another it is good but with NeuVector we can go further and block any connection that is not meant to happen, per pod, not just per namespace, with multitenancy if a pod in your namespace goes rogue it can impact other pods in the same namespace and we don't want that, with zero-trust we want each pod to be able to connect only to what it should and nothing else... creating zero-trust policies is easy with the discover mode... but in case you still want to limit by namespace this is how you can do it.

In this post we use NeuVector to achieves same results.

===  Pod inter-communications
To explain how Pod inter-communications lets try a simple sample

[source,bash]
----
# ceate first sample application
oc new-project sample1
oc new-app httpd

# ceate Second sample application
oc new-project sample2
oc new-app httpd

# ceate Third sample application
oc new-project sample3
oc new-app httpd

----

Now lets try to play with curl to check communication accessibility

[source,bash]
----
# From sample1 call sample2
oc exec -n sample1 $(oc get po -n sample1 -l deployment=httpd -o name) -- curl --max-time 2 http://httpd.sample2.svc.cluster.local:8080
# From sample1 call sample3
oc exec -n sample1 $(oc get po -n sample1 -l deployment=httpd -o name) -- curl --max-time 2 http://httpd.sample3.svc.cluster.local:8080

# From sample2 call sample1
oc exec -n sample2 $(oc get po -n sample2 -l deployment=httpd -o name) -- curl --max-time 2 http://httpd.sample1.svc.cluster.local:8080
# From sample2 call sample3
oc exec -n sample2 $(oc get po -n sample2 -l deployment=httpd -o name) -- curl --max-time 2 http://httpd.sample3.svc.cluster.local:8080

# From sample3 call sample1
oc exec -n sample3 $(oc get po -n sample3 -l deployment=httpd -o name) -- curl --max-time 2 http://httpd.sample1.svc.cluster.local:8080
# From sample3 call sample2
oc exec -n sample3 $(oc get po -n sample3 -l deployment=httpd -o name) -- curl --max-time 2 http://httpd.sample2.svc.cluster.local:8080

----

Then we will expose the apache HTTP server so it can be externally accessibility

[source,bash]
----
oc expose svc/httpd  -n sample1
oc expose svc/httpd  -n sample2
oc expose svc/httpd  -n sample3

curl "http://$(oc get route -n sample1 -l  app.kubernetes.io/component=httpd  -o go-template='{{range .items}}{{.spec.host}}{{end}}')" 

curl "http://$(oc get route -n sample2 -l  app.kubernetes.io/component=httpd  -o go-template='{{range .items}}{{.spec.host}}{{end}}')" 

curl "http://$(oc get route -n sample3 -l  app.kubernetes.io/component=httpd  -o go-template='{{range .items}}{{.spec.host}}{{end}}')" 
----

We so our tests so NeuVector can discover our access behavior and how traffic flow to the workload.

== Configuring multitenant isolation using NeuVector Network rules

First thing is to ensure that NV Network Security Policy Mode is Protect so it blocks any communication unless there is an explicit Network rule to enable it. You can do this through settings page.

image::img/network_protect.jpg[]

IMPORTANT: Once you enable Network Security Policy Mode as Protect, all cluster communication will be blocked unless explicitly enabled.  

The link:NvSecurityRule-multitenant-allow-external.yaml[NvSecurityRule-multitenant-allow-external] will create multitenant isolation on namespace sample1, so pods within sample1 only are allowed to communicate, and also incoming communication from both ingress, external and monitoring.

You can import the NvSecurityRule by using UI Policy>Group>Import Group Policy

image::img/import_rule.jpg[]

for more information please refer to https://open-docs.neuvector.com/policy/usingcrd/import

Now lets try again previous curl to check communication accessibility

[source,bash]
----
# From sample2 call sample1 -- It should fail
oc exec -n sample2 $(oc get po -n sample2 -l deployment=httpd -o name) -- curl --max-time 2 http://httpd.sample1.svc.cluster.local:8080

# From sample3 call sample1 -- It should fail
oc exec -n sample3 $(oc get po -n sample3 -l deployment=httpd -o name) -- curl --max-time 2 http://httpd.sample1.svc.cluster.local:8080


# From sample1 call sample1 -- It should succeeded
oc exec -n sample1 $(oc get po -n sample1 -l deployment=httpd -o name) -- curl --max-time 2 http://httpd.sample1.svc.cluster.local:8080

# Now test from ingress as it should successes 
curl "http://$(oc get route -n sample1 -l  app.kubernetes.io/component=httpd  -o go-template='{{range .items}}{{.spec.host}}{{end}}')" 
----

== Disallow external ingress communication using NeuVector Network rules

The link:NvSecurityRule-multitenant-disallow-external.yaml[NvSecurityRule-multitenant-disallow-external] will also disallow incoming communication from external through the exposed route.

You can import the NvSecurityRule by using UI Policy>Group>Import Group Policy

image::img/import_rule.jpg[]

Now lets try again previous curl to check communication accessibility

[source,bash]
----
# Now test from ingress as it should fail 
curl "http://$(oc get route -n sample1 -l  app.kubernetes.io/component=httpd  -o go-template='{{range .items}}{{.spec.host}}{{end}}')" 
----

== Disallow external egress communication using NeuVector Network rules

In OpenShift, there are two Container Network Interface (CNI) OVN-Kubernetes & OpenShift SDN.
OpenShift SDN CNI till 4.9 was not supporting Network policy egress as specified by the egress field, for more info please refer to https://docs.openshift.com/container-platform/4.9/networking/network_policy/about-network-policy.html#nw-networkpolicy-about_about-network-policy[About network policy]

Both CNIs have an Egress firewall feature, for OVN-Kubernetes it is called EgressFirewall, for more information please refer to https://docs.openshift.com/container-platform/4.13/networking/ovn_kubernetes_network_provider/configuring-egress-firewall-ovn.html[Configuring an egress firewall for a project], and for OpenShift SDN it is called EgressNetworkPolicy https://docs.openshift.com/container-platform/4.13/networking/openshift_sdn/configuring-egress-firewall.html[Configuring an egress firewall for a project].


The nice thing about EgressFirewall or EgressNetworkPolicy is that they can limit communication based on DNS record (dnsName) unlike Network policy which is based on ipBlock or pod selectors and/or namespace selectors. so it become handy in blocking connection to external internet DNS, for more info. please refer to https://kubernetes.io/docs/concepts/services-networking/network-policies/#behavior-of-to-and-from-selectors[Behavior of to and from selectors]

But there are also limitations in this egress control, which in OpenShift you can create one egress control policy (EgressFirewall or EgressNetworkPolicy) per namespace, https://docs.openshift.com/container-platform/4.13/networking/ovn_kubernetes_network_provider/configuring-egress-firewall-ovn.html#limitations-of-an-egress-firewall_configuring-egress-firewall-ovn[OVN Kubernetes Limitations of an egress firewall] & https://docs.openshift.com/container-platform/4.13/networking/openshift_sdn/configuring-egress-firewall.html#limitations-of-an-egress-firewall_openshift-sdn-egress-firewall[openshift SDN Limitations of an egress firewall]

also other limitations include;
* Namespace only, no pod selectors to further refine egress controls
* No application protocol verification (e.g. mysql, …) to further secure connections by layer7 application protocol (this also is a limitation in network policy)
* Limited rule management, where the order of definition in the yaml file is the method and can’t be compared to other global rules


The link:NvSecurityRule-multitenant-disallow-external.yaml[NvSecurityRule-multitenant-disallow-external] will also disallow incoming communication from external through the exposed route.

You can import the NvSecurityRule by using UI Policy>Group>Import Group Policy

image::img/import_rule.jpg[]

Now lets try again previous curl to check communication accessibility

[source,bash]
----

# From sample1 call google.com -- it should fail 
oc exec -n sample1 $(oc get po -n sample1 -l deployment=httpd -o name) -- curl --max-time 2 https://google.com

# From sample1 call suse.com -- it should succeed 
oc exec -n sample1 $(oc get po -n sample1 -l deployment=httpd -o name) -- curl --max-time 2 https://suse.com
----

