= Introduction to NeuVector Files/Process rules

In this post we will examine using NeuVector Network rules we will try to understand its basics and usage.


.References :
* https://open-docs.neuvector.com/policy/processrules/


:sectnums:

== What is the difference between Zero-drift and basic protection in Neuvector

In NeuVector, zero-drift and basic protection are two distinct approaches to securing processes and file systems within your containerized environment. They differ in their underlying philosophy and how they establish and enforce security policies. 

Here's a breakdown of the key differences:

== Zero-Drift Protection:

* Philosophy: Enforces strict adherence to the *original* container image and the processes observed during the learning phase (Discover mode) initiated by the parent process in the original image. It operates on the principle of immutability.

* Learning: Automatically learns the allowed processes and file activity based on what's present and executed from the initial container image during the Discover mode.

* Policy Enforcement:

** Processes: Only allows processes that originated from the parent process in the original image and were observed during the learning phase. Any new or unexpected processes are flagged as violations (Monitor mode) or blocked (Protect mode).
** File Systems: Does not allow file updates or the installation of new files within the container at runtime by default.

* Initial Configuration: Requires a learning period in Discover mode to establish the baseline. Minimal manual rule creation is needed initially.

* Use Cases: Best suited for hardened, minimal container images where runtime changes are generally not expected. It's effective at detecting and preventing the execution of malicious or unexpected * processes introduced by attackers. 

* Strictness: More restrictive by default, as it flags any deviation from the initially learned behavior.

== Basic Protection:

* Philosophy: Provides broader protection based on explicitly defined process and file rules for each security group. It relies on a list of allowed or denied activities.   

* Learning: Can automatically learn process and file activity during Discover mode, but these learned behaviors are added as explicit rules to the security group's policy. You can also manually create these rules through the NeuVector console or API.   

* Policy Enforcement:

** Processes: Enforces based on the defined list of allowed and denied process rules (name and/or path). If a process doesn't match an allow rule (and doesn't match a deny rule), it will be flagged or blocked in Monitor/Protect mode.   

** File Systems: Enforces based on defined file access rules, allowing you to monitor or block specific file or directory modifications and access.   
Initial Configuration: Might require more manual configuration of process and file rules, especially for complex applications or when zero-drift is disabled.

* Use Cases: More flexible and can accommodate applications with legitimate runtime changes or those built from less strictly controlled images. It allows for more granular control over specific processes and file activities.

* Strictness: Can be less restrictive than zero-drift if not configured with comprehensive rules. If no rules are in place in Basic mode, all new activity might be flagged or blocked in Monitor/Protect mode.   

Here's a table summarizing the key differences:

[%header,cols="2,3,3"]
|===
|Feature| Zero-Drift Protection |	Basic Protection 
|Core Principle	
|Adherence to the original image's initial behavior	
|Enforcement based on explicit allow/deny rules

|Learning	
|Automatic learning of initial processes from the image	
|Automatic learning adds rules to the policy; manual creation

|Process Policy	
|Allows only initially observed processes from the parent	
|Enforces against a list of allowed/denied processes

|File Policy	
|Disallows runtime file changes by default	
|Enforces based on defined file access rules

|Initial Config	
|Minimal, relies on learning phase	
|Can require more manual rule creation

|Flexibility	
|Less flexible for runtime changes	
|More flexible, allows for specific rules

|Strictness	
|More restrictive by default	
|Can be less restrictive if rules are not comprehensive

|Best For	
|Hardened images, minimal runtime changes	
|Applications with legitimate runtime changes, granular control

|=== 

== In essence:

* Zero-drift aims for a "trust the original image" approach, automatically preventing deviations.
* Basic protection relies on explicitly defining what is allowed or denied, offering more granular control but potentially requiring more manual configuration.

_You can choose the protection mode (Zero-drift or Basic) for each security group in NeuVector based on the specific needs and characteristics of your containerized applications._ 

[IMPORTANT]
====
It's recommended to set system-trusted (de-facto) namespaces (system and network-plugin) using Basic protection to allow for necessary updates and changes. Example namespaces to set are "kube-system", "openshift-ovn-kubernetes", "ovn-*" etc. Set other namespaces as zero-drift.
====